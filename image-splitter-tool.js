import React, { useState, useRef, useEffect, useCallback } from 'react';

// Reusable InfoModal Component
const InfoModal = ({ title, children, isOpen, onClose }) => {
  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4"
      onClick={onClose} // Close when clicking outside the modal content
    >
      <div
        className="bg-white rounded-xl shadow-2xl p-6 max-w-md w-full relative transform transition-all duration-300 ease-out scale-95 opacity-0 animate-scaleIn"
        onClick={e => e.stopPropagation()} // Prevent closing when clicking inside the modal content
      >
        <button
          onClick={onClose}
          className="absolute top-3 right-3 text-gray-500 hover:text-gray-700 text-2xl font-bold focus:outline-none"
          aria-label="Close"
        >
          &times;
        </button>
        <h2 className="text-xl font-bold mb-3 text-gray-900">{title}</h2>
        <div className="text-sm text-gray-700 leading-relaxed space-y-2">
          {children} {/* Render children directly */}
        </div>
      </div>
    </div>
  );
};

// Main App component for the AI Image Splitter
const App = () => {
  // State to store the URL of the uploaded image
  const [imageSrc, setImageSrc] = useState(null);
  // State to store the actual Image object once loaded
  const [originalImage, setOriginalImage] = useState(null);
  // State to store an array of y-coordinates for horizontal cuts.
  // These Y-coordinates are now relative to the BOTTOM-LEFT corner of the original image.
  const [horizontalCutPoints, setHorizontalCutPoints] = useState([]);
  // State to store an array of x-coordinates for vertical cuts.
  // These X-coordinates are relative to the BOTTOM-LEFT (or TOP-LEFT) corner of the original image.
  const [verticalCutPoints, setVerticalCutPoints] = useState([]);
  // State to manage the progression of auto-generated horizontal divisions (0: initial, 1: halves, 2: thirds, etc.)
  const [horizontalDivisionIteration, setHorizontalDivisionIteration] = useState(0);
  // State to manage the progression of auto-generated vertical divisions
  const [verticalDivisionIteration, setVerticalDivisionIteration] = useState(0);
  // State to store an array of extracted image data URLs (always PNG for internal processing)
  const [extractedImages, setExtractedImages] = useState([]);
  // State to manage loading indicator during image processing
  const [isLoading, setIsLoading] = useState(false);
  // State to display error messages to the user
  const [errorMessage, setErrorMessage] = useState('');
  // State to manage loading during batch download (for individual or zip)
  const [isDownloading, setIsDownloading] = useState(false);
  // State to store the description of the original image generated by LLM
  const [originalImageDescription, setOriginalImageDescription] = useState(null); // null, 'loading', 'error', or string
  // State to store descriptions for each extracted segment: {index: {title: string, description: string, status: 'loading' | 'error' | 'success'}}
  const [segmentDescriptions, setSegmentDescriptions] = useState({});
  // State to manage loading when analyzing all segments
  const [isAnalyzingAll, setIsAnalyzingAll] = useState(false);
  // State for group name input
  const [groupName, setGroupName] = useState('');
  // State for group name info modal visibility
  const [showGroupInfoModal, setShowGroupInfoModal] = useState(false);


  // State for info modal visibility
  const [showWhyModal, setShowWhyModal] = useState(false);
  const [showHowToUseModal, setShowHowToUseModal] = useState(false);
  const [showPrivacyModal, setShowPrivacyModal] = useState(false);


  // Ref for the main canvas used to display the original image
  const canvasRef = useRef(null);

  // Ref for continuous adjustment interval for buttons
  const intervalRef = useRef(null);

  /**
   * Converts a given image data URL to a base64 string suitable for Gemini API.
   * Removes the "data:image/png;base64," prefix.
   * @param {string} dataUrl - The data URL of the image.
   * @returns {string} The base64 encoded image data.
   */
  const getBase64ImageFromDataUrl = (dataUrl) => {
    return dataUrl.split(',')[1];
  };

  /**
   * Handles the file input change event.
   * Reads the uploaded image file and sets it to state.
   * @param {Object} event - The file input change event.
   */
  const handleImageUpload = (event) => {
    const file = event.target.files[0];
    if (file) {
      // Clear any previous error messages
      setErrorMessage('');
      // Check if the uploaded file is an image
      if (!file.type.startsWith('image/')) {
        setErrorMessage('Please upload an image file (e.g., PNG, JPG, GIF).');
        setImageSrc(null);
        setOriginalImage(null);
        setExtractedImages([]);
        setHorizontalCutPoints([]); // Clear cut points
        setVerticalCutPoints([]);   // Clear cut points
        setHorizontalDivisionIteration(0); // Reset division iteration
        setVerticalDivisionIteration(0);   // Reset division iteration
        setOriginalImageDescription(null); // Clear previous description
        setSegmentDescriptions({}); // Clear previous segment descriptions
        return;
      }

      const reader = new FileReader();
      reader.onload = (e) => {
        setImageSrc(e.target.result); // Set the image source for display
        const img = new Image();
        img.onload = () => {
          setOriginalImage(img); // Set the Image object
          setExtractedImages([]); // Clear previous extractions
          setHorizontalCutPoints([]); // Reset cut points on new image
          setVerticalCutPoints([]);   // Reset cut points on new image
          setHorizontalDivisionIteration(0); // Reset division iteration
          setVerticalDivisionIteration(0);   // Reset division iteration
          setOriginalImageDescription(null); // Clear previous description
          setSegmentDescriptions({}); // Clear previous segment descriptions
        };
        img.onerror = () => {
          setErrorMessage('Failed to load image. It might be corrupted or an unsupported format.');
          setImageSrc(null);
          setOriginalImage(null);
          setExtractedImages([]);
          setHorizontalCutPoints([]);
          setVerticalCutPoints([]);
          setHorizontalDivisionIteration(0);
          setVerticalDivisionIteration(0);
          setOriginalImageDescription(null);
          setSegmentDescriptions({});
        };
        img.src = e.target.result; // Set the source of the Image object
      };
      reader.readAsDataURL(file); // Read the file as a data URL
    } else {
      setImageSrc(null);
      setOriginalImage(null);
      setExtractedImages([]);
      setHorizontalCutPoints([]);
      setVerticalCutPoints([]);
      setHorizontalDivisionIteration(0);
      setVerticalDivisionIteration(0);
      setErrorMessage('');
      setOriginalImageDescription(null);
      setSegmentDescriptions({});
    }
  };

  /**
   * Function to draw the image and cut lines on the canvas.
   * Memoized using useCallback to prevent unnecessary re-renders.
   */
  const drawImageAndLines = useCallback(() => {
    const canvas = canvasRef.current;
    if (originalImage && canvas) {
      const ctx = canvas.getContext('2d');

      // Adjust canvas dimensions to fit the image while maintaining aspect ratio for display
      const maxWidth = 800;
      const maxHeight = 600;

      let displayWidth = originalImage.width;
      let displayHeight = originalImage.height;

      // Scale down image for display if it's too large
      if (displayWidth > maxWidth) {
        displayHeight = displayHeight * (maxWidth / displayWidth);
        displayWidth = maxWidth;
      }
      if (displayHeight > maxHeight) {
        displayWidth = displayWidth * (maxHeight / displayHeight);
        displayHeight = maxHeight;
      }

      canvas.width = displayWidth;
      canvas.height = displayHeight;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(originalImage, 0, 0, displayWidth, displayHeight);

      // Set line style for cut lines
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]); // Dashed lines

      // Draw horizontal cut lines
      // Y-coordinates are from bottom-left origin in state, convert to top-left for canvas drawing
      horizontalCutPoints.forEach(y => {
        const scaledCanvasY = displayHeight - (y / originalImage.height) * displayHeight;
        // Draw only if the line is within the visible canvas bounds, avoiding lines at 0 or max height
        if (scaledCanvasY > 0 && scaledCanvasY < displayHeight) {
          ctx.beginPath();
          ctx.moveTo(0, scaledCanvasY);
          ctx.lineTo(displayWidth, scaledCanvasY);
          ctx.stroke();
        }
      });

      // Draw vertical cut lines
      // X-coordinates are from bottom-left (same as top-left) for canvas drawing
      verticalCutPoints.forEach(x => {
        const scaledCanvasX = (x / originalImage.width) * displayWidth;
        // Draw only if the line is within the visible canvas bounds, avoiding lines at 0 or max width
        if (scaledCanvasX > 0 && scaledCanvasX < displayWidth) {
          ctx.beginPath();
          ctx.moveTo(scaledCanvasX, 0);
          ctx.lineTo(scaledCanvasX, displayHeight);
          ctx.stroke();
        }
      });

      ctx.setLineDash([]); // Reset line dash to solid for future drawings
    }
  }, [originalImage, horizontalCutPoints, verticalCutPoints]);

  // Effect to handle drawing the image and lines on the canvas when dependencies change
  useEffect(() => {
    drawImageAndLines();
  }, [drawImageAndLines]);

  /**
   * Helper to generate evenly spaced points for a given dimension and divisor.
   * @param {number} dimension - The total dimension (width or height) of the image.
   * @param {number} divisor - The number of segments (e.g., 2 for halves, 3 for thirds).
   * @returns {number[]} An array of pixel coordinates for the cut lines.
   */
  const getEvenlySpacedPoints = (dimension, divisor) => {
    const points = [];
    if (divisor <= 1) return points; // Cannot divide into 1 or fewer segments (no cut lines)
    for (let i = 1; i < divisor; i++) {
      points.push(Math.round(dimension * i / divisor));
    }
    return points;
  };

  /**
   * Helper to find the closest point in an array to a given value.
   * @param {number} value - The value to find the closest point for.
   * @param {number[]} pointsArray - The array of points to search within.
   * @returns {number | null} The closest point found, or null if pointsArray is empty.
   */
  const findClosestPoint = (value, pointsArray) => {
    if (pointsArray.length === 0) return null;
    let closest = pointsArray[0];
    let minDiff = Math.abs(value - pointsArray[0]);
    for (let i = 1; i < pointsArray.length; i++) {
      const diff = Math.abs(value - pointsArray[i]);
      if (diff < minDiff) {
        minDiff = diff;
        closest = pointsArray[i];
      }
    }
    return closest;
  };


  /**
   * Adds a new horizontal cut point based on the next division iteration.
   * Automatically calculates evenly spaced lines and preserves manual adjustments.
   * Horizontal cut points (Y) are relative to the bottom of the image.
   */
  const addHorizontalCutPoint = () => {
    if (!originalImage) {
      setErrorMessage('Please upload an image first to add cut points.');
      return;
    }

    setHorizontalDivisionIteration(prevIteration => {
      const nextIteration = prevIteration + 1;
      const maxDivisions = 16; // Capping at 1/16th divisions (meaning 15 cut lines)
      if (nextIteration > maxDivisions) {
        setErrorMessage(`Maximum horizontal divisions reached (${maxDivisions} segments, ${maxDivisions - 1} cuts).`);
        return prevIteration;
      }
      setErrorMessage('');

      // Determine the *previous* auto-generated set of points (bottom-up Y)
      const previousDivisor = prevIteration + 1;
      const previousAutoGeneratedPoints = getEvenlySpacedPoints(originalImage.height, previousDivisor);

      // Determine the *new* auto-generated set of points (bottom-up Y) based on the *next* iteration
      const newDivisor = nextIteration + 1;
      const newEvenlySpacedPoints = getEvenlySpacedPoints(originalImage.height, newDivisor);

      // The set to build up the new horizontal cut points
      const updatedCutPoints = new Set(newEvenlySpacedPoints); // Start with the new auto-generated points

      // Iterate through the *currently existing* horizontal cut points (from the previous state)
      horizontalCutPoints.forEach(currentPoint => {
        // Check if this `currentPoint` was a "true manual override" from the perspective of the *previous* iteration.
        // A true manual override is a point that was *not* close (more than 2px) to any of the `previousAutoGeneratedPoints`.
        let isTrueManualOverride = true;
        if (previousAutoGeneratedPoints.length > 0) {
          for (const pAuto of previousAutoGeneratedPoints) {
            if (Math.abs(currentPoint - pAuto) <= 2) {
              isTrueManualOverride = false; // It snapped to a previous auto point, so it's not a "true manual" one from the start
              break;
            }
          }
        }

        if (isTrueManualOverride) {
          // If it was a truly manual point previously, keep it.
          updatedCutPoints.add(currentPoint);
        } else {
          // This `currentPoint` *was* an auto-generated point (or snapped to one) from the previous iteration.
          // Now, check if the user has moved it significantly from its *previous auto position*.
          const closestPreviousAuto = findClosestPoint(currentPoint, previousAutoGeneratedPoints);

          if (closestPreviousAuto !== null && Math.abs(currentPoint - closestPreviousAuto) > 2) {
            // It was an auto-point, but it was moved significantly (> 2px) from its *previous* auto-generated position.
            // So, it should now be treated as a manual override and preserved.
            updatedCutPoints.add(currentPoint);
          }
          // If closestPreviousAuto is null OR if Math.abs(currentPoint - closestPreviousAuto) <= 2,
          // then this point is implicitly replaced by the `newEvenlySpacedPoints` which are already in `updatedCutPoints`.
        }
      });

      // Set the horizontal cut points for the next render, sorted for consistent order
      setHorizontalCutPoints(Array.from(updatedCutPoints).sort((a, b) => a - b));

      // Return the new iteration value to update the state correctly
      return nextIteration;
    });
  };

  /**
   * Adds a new vertical cut point based on the next division iteration.
   * Automatically calculates evenly spaced lines and preserves manual adjustments.
   * Vertical cut points (X) are relative to the left of the image.
   */
  const addVerticalCutPoint = () => {
    if (!originalImage) {
      setErrorMessage('Please upload an image first to add cut points.');
      return;
    }

    setVerticalDivisionIteration(prevIteration => {
      const nextIteration = prevIteration + 1;
      const maxDivisions = 16;
      if (nextIteration > maxDivisions) {
        setErrorMessage(`Maximum vertical divisions reached (${maxDivisions} segments, ${maxDivisions - 1} cuts).`);
        return prevIteration;
      }
      setErrorMessage('');

      const previousDivisor = prevIteration + 1;
      const previousAutoGeneratedPoints = getEvenlySpacedPoints(originalImage.width, previousDivisor);

      const newDivisor = nextIteration + 1;
      const newEvenlySpacedPoints = getEvenlySpacedPoints(originalImage.width, newDivisor);

      const updatedCutPoints = new Set(newEvenlySpacedPoints);

      verticalCutPoints.forEach(currentPoint => {
        let isTrueManualOverride = true;
        if (previousAutoGeneratedPoints.length > 0) {
          for (const pAuto of previousAutoGeneratedPoints) {
            if (Math.abs(currentPoint - pAuto) <= 2) {
              isTrueManualOverride = false;
              break;
            }
          }
        }

        if (isTrueManualOverride) {
          updatedCutPoints.add(currentPoint);
        } else {
          const closestPreviousAuto = findClosestPoint(currentPoint, previousAutoGeneratedPoints);
          if (closestPreviousAuto !== null && Math.abs(currentPoint - closestPreviousAuto) > 2) {
            updatedCutPoints.add(currentPoint);
          }
        }
      });

      setVerticalCutPoints(Array.from(updatedCutPoints).sort((a, b) => a - b));
      return nextIteration;
    });
  };

  /**
   * Removes a horizontal cut point by its index.
   * @param {number} index - The index of the cut point to remove.
   */
  const removeHorizontalCutPoint = (index) => {
    setHorizontalCutPoints(prev => {
      const newPoints = prev.filter((_, i) => i !== index);
      // If all points are removed, reset division iteration
      if (newPoints.length === 0) {
        setHorizontalDivisionIteration(0);
      }
      return newPoints;
    });
  };

  /**
   * Removes a vertical cut point by its index.
   * @param {number} index - The index of the cut point to remove.
   */
  const removeVerticalCutPoint = (index) => {
    setVerticalCutPoints(prev => {
      const newPoints = prev.filter((_, i) => i !== index);
      // If all points are removed, reset division iteration
      if (newPoints.length === 0) {
        setVerticalDivisionIteration(0);
      }
      return newPoints;
    });
  };

  /**
   * Updates a horizontal cut point at a specific index.
   * Ensures the value is within the image height bounds.
   * @param {number} index - The index of the cut point to update.
   * @param {string | number} value - The new value for the cut point.
   */
  const updateHorizontalCutPoint = (index, value) => {
    const parsedValue = typeof value === 'string' ? parseInt(value, 10) : value;
    if (!isNaN(parsedValue) && originalImage) {
      // Ensure the cut point is within the image bounds (0 to height)
      const clampedValue = Math.max(0, Math.min(originalImage.height, parsedValue));
      setHorizontalCutPoints(prev => {
        const newPoints = [...prev];
        newPoints[index] = clampedValue;
        return newPoints.sort((a, b) => a - b); // Keep sorted
      });
    } else if (value === '') { // Allow clearing the input temporarily
      setHorizontalCutPoints(prev => {
        const newPoints = [...prev];
        newPoints[index] = ''; // Set to empty string to allow user to type
        return newPoints;
      });
    }
  };

  /**
   * Updates a vertical cut point at a specific index.
   * Ensures the value is within the image width bounds.
   * @param {number} index - The index of the cut point to update.
   * @param {string | number} value - The new value for the cut point.
   */
  const updateVerticalCutPoint = (index, value) => {
    const parsedValue = typeof value === 'string' ? parseInt(value, 10) : value;
    if (!isNaN(parsedValue) && originalImage) {
      // Ensure the cut point is within the image bounds (0 to width)
      const clampedValue = Math.max(0, Math.min(originalImage.width, parsedValue));
      setVerticalCutPoints(prev => {
        const newPoints = [...prev];
        newPoints[index] = clampedValue;
        return newPoints.sort((a, b) => a - b); // Keep sorted
      });
    } else if (value === '') { // Allow clearing the input temporarily
      setVerticalCutPoints(prev => {
        const newPoints = [...prev];
        newPoints[index] = ''; // Set to empty string to allow user to type
        return newPoints;
      });
    }
  };

  /**
   * Handles the extraction of images based on the specified custom cut points.
   * Creates new canvases for each segment and stores their data URLs.
   */
  const handleExtractImages = () => {
    setErrorMessage('');
    if (!originalImage) {
      setErrorMessage('Please upload an image first.');
      return;
    }

    setIsLoading(true);
    setExtractedImages([]);
    setSegmentDescriptions({}); // Clear segment descriptions on new extraction

    const imageWidth = originalImage.width;
    const imageHeight = originalImage.height;

    // Y-coordinates are from bottom-left origin, so sorting them naturally gives low to high Y.
    // For `drawImage` (which uses top-left origin), we need to compute `sy` (source Y) as
    // `imageHeight - currentSegmentTopY_bottomUp`.
    // The heights are calculated as `currentSegmentTopY_bottomUp - currentSegmentBottomY_bottomUp`.
    const allHorizontalCuts = [...new Set([0, ...horizontalCutPoints.filter(p => typeof p === 'number'), imageHeight])].sort((a, b) => a - b);
    const allVerticalCuts = [...new Set([0, ...verticalCutPoints.filter(p => typeof p === 'number'), imageWidth])].sort((a, b) => a - b);

    const newExtractedImages = [];

    // Iterate through horizontal segments from top to bottom of the image for drawing purposes.
    // This means iterating `allHorizontalCuts` in reverse order for the `topY` and `bottomY` of each segment.
    for (let i = allHorizontalCuts.length - 1; i > 0; i--) {
      const currentSegmentTopY_bottomUp = allHorizontalCuts[i];    // e.g., for 1024x1024, if cuts are 341, 683, 1024, this could be 1024, then 683, then 341.
      const currentSegmentBottomY_bottomUp = allHorizontalCuts[i - 1]; // e.g., for 1024x1024, this could be 683, then 341, then 0.
      
      const sHeight = currentSegmentTopY_bottomUp - currentSegmentBottomY_bottomUp;

      // Skip invalid height segments
      if (sHeight <= 0) continue;

      // Calculate sy (source Y) for drawImage, which uses a TOP-LEFT origin.
      // This is the distance from the top of the original image to the top of the current segment.
      const sy_for_drawImage = imageHeight - currentSegmentTopY_bottomUp;

      for (let j = 0; j < allVerticalCuts.length - 1; j++) {
        const sx = allVerticalCuts[j];
        const sWidth = allVerticalCuts[j + 1] - sx;

        // Skip invalid width segments
        if (sWidth <= 0) continue;

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = sWidth;
        tempCanvas.height = sHeight;
        const tempCtx = tempCanvas.getContext('2d');

        // Draw the specific segment of the original image onto the temporary canvas
        tempCtx.drawImage(originalImage, sx, sy_for_drawImage, sWidth, sHeight, 0, 0, sWidth, sHeight);

        newExtractedImages.push(tempCanvas.toDataURL('image/png')); // Always extract as PNG initially for best quality/transparency
      }
    }
    setExtractedImages(newExtractedImages);
    setIsLoading(false);
  };


  /**
   * Handles downloading all extracted images as individual files.
   * Also generates a text file with descriptions if available.
   */
  const handleBatchDownload = async () => {
    if (extractedImages.length === 0) {
      setErrorMessage('No images to download. Please extract images first.');
      return;
    }

    setIsDownloading(true);
    setErrorMessage('');

    const baseFileName = groupName ? `${groupName}_` : '';
    let descriptionsContent = '';

    for (let i = 0; i < extractedImages.length; i++) {
      const imgDataUrl = extractedImages[i];
      const filename = `${baseFileName}segment_${i + 1}.png`;
      
      // Fetch the image data as a Blob
      const response = await fetch(imgDataUrl);
      const imageDataBlob = await response.blob();

      // Trigger download for each image
      const link = document.createElement('a');
      link.href = URL.createObjectURL(imageDataBlob);
      link.download = filename;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(link.href); // Clean up the object URL

      // Append segment description to the descriptions content
      const segmentInfo = segmentDescriptions[i];
      if (segmentInfo && segmentInfo.status === 'success') {
        descriptionsContent += `Segment ${i + 1} (${filename}):\n`;
        descriptionsContent += `  Title: ${segmentInfo.title || 'N/A'}\n`;
        descriptionsContent += `  Description: ${segmentInfo.description || 'N/A'}\n\n`;
      }

      // Small delay between downloads to prevent browser issues
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    // Generate and download the text file with all descriptions if content exists
    if (descriptionsContent) {
      const textFileName = `${baseFileName}image_descriptions.txt`;
      const textBlob = new Blob([descriptionsContent], { type: 'text/plain;charset=utf-8' });
      // Using FileSaver.js's saveAs function
      if (typeof saveAs === 'function') {
        saveAs(textBlob, textFileName);
      } else {
        // Fallback if FileSaver.js is not loaded
        const link = document.createElement('a');
        link.href = URL.createObjectURL(textBlob);
        link.download = textFileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
      }
    }

    setIsDownloading(false);
  };

  /**
   * Calls the Gemini API to get a description of the original image.
   */
  const handleDescribeOriginalImage = async () => {
    if (!originalImage) {
      setErrorMessage('Please upload an image first to describe it.');
      return;
    }
    setOriginalImageDescription('loading');
    setErrorMessage('');

    try {
      // Create an offscreen canvas to get data URL of the original image
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = originalImage.width;
      tempCanvas.height = originalImage.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(originalImage, 0, 0);
      const base64ImageData = getBase64ImageFromDataUrl(tempCanvas.toDataURL('image/png'));

      const prompt = "Describe this image in detail, focusing on its main subjects, colors, and overall composition. Be concise.";
      let chatHistory = [];
      chatHistory.push({ role: "user", parts: [{ text: prompt }] });
      const payload = {
        contents: [
          {
            role: "user",
            parts: [
              { text: prompt },
              {
                inlineData: {
                  mimeType: "image/png", // Assuming PNG for output, adjust if needed
                  data: base64ImageData
                }
              }
            ]
          }
        ],
      };
      const apiKey = ""; // Canvas will automatically provide the API key
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const result = await response.json();

      if (result.candidates && result.candidates.length > 0 &&
          result.candidates[0].content && result.candidates[0].content.parts &&
          result.candidates[0].content.parts.length > 0) {
        const text = result.candidates[0].content.parts[0].text;
        setOriginalImageDescription(text);
      } else {
        setOriginalImageDescription('error');
        setErrorMessage('Failed to get description for the original image. Please try again.');
        console.error('Gemini API response structure unexpected:', result);
      }
    } catch (error) {
      setOriginalImageDescription('error');
      setErrorMessage(`Error describing original image: ${error.message}`);
      console.error('Error calling Gemini API for original image:', error);
    }
  };

  /**
   * Calls the Gemini API to get a description of a specific image segment.
   * @param {string} imgDataUrl - The data URL of the segment image.
   * @param {number} index - The index of the segment.
   * @returns {Promise<void>} A promise that resolves when the analysis is complete.
   */
  const handleAnalyzeSegment = async (imgDataUrl, index) => {
    setSegmentDescriptions(prev => ({ ...prev, [index]: { ...prev[index], status: 'loading' } }));
    setErrorMessage(''); // Clear individual segment errors if retrying

    try {
      const base64ImageData = getBase64ImageFromDataUrl(imgDataUrl);

      // Prompt for both a concise title and a brief description
      const prompt = "Provide a very short, concise title (under 5 words) and a brief description (under 30 words) for this image segment, in JSON format. Example: { \"title\": \"Cute Cat\", \"description\": \"A small, fluffy cat with green eyes sitting on a couch.\" }";
      
      let chatHistory = [];
      chatHistory.push({ role: "user", parts: [{ text: prompt }] });
      const payload = {
        contents: [
          {
            role: "user",
            parts: [
              { text: prompt },
              {
                inlineData: {
                  mimeType: "image/png", // Assuming PNG for input, adjust if needed
                  data: base64ImageData
                }
              }
            ]
          }
        ],
        generationConfig: {
          responseMimeType: "application/json",
          responseSchema: {
            type: "OBJECT",
            properties: {
              "title": { "type": "STRING" },
              "description": { "type": "STRING" }
            },
            "propertyOrdering": ["title", "description"]
          }
        }
      };
      const apiKey = ""; // Canvas will automatically provide the API key
      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      const result = await response.json();

      // IMPORTANT FIX: Check if result.candidates[0].content.parts[0].text exists and is a non-empty string
      if (result.candidates && result.candidates.length > 0 &&
          result.candidates[0].content && result.candidates[0].content.parts &&
          result.candidates[0].content.parts.length > 0 &&
          typeof result.candidates[0].content.parts[0].text === 'string' &&
          result.candidates[0].content.parts[0].text.trim() !== '') {
        try {
          const json = result.candidates[0].content.parts[0].text;
          const parsedJson = JSON.parse(json);
          setSegmentDescriptions(prev => ({
            ...prev,
            [index]: { title: parsedJson.title, description: parsedJson.description, status: 'success' }
          }));
        } catch (parseError) {
          setSegmentDescriptions(prev => ({ ...prev, [index]: { ...prev[index], status: 'error' } }));
          console.error(`Error parsing JSON for segment ${index}:`, parseError, "Received text:", result.candidates[0].content.parts[0].text);
        }
      } else {
        setSegmentDescriptions(prev => ({ ...prev, [index]: { ...prev[index], status: 'error' } }));
        // Log the error but don't set global error message unless all fail
        console.error(`Gemini API response for segment ${index} was empty or malformed:`, result);
      }
    } catch (error) {
      setSegmentDescriptions(prev => ({ ...prev, [index]: { ...prev[index], status: 'error' } }));
      // Log the error but don't set global error message unless all fail
      console.error(`Error analyzing segment ${index} during fetch:`, error);
    }
  };

  /**
   * Analyzes all extracted segments using the Gemini API sequentially with delays.
   */
  const handleAnalyzeAllSegments = async () => {
    if (extractedImages.length === 0) {
      setErrorMessage('No segments to analyze. Please extract segments first.');
      return;
    }
    setIsAnalyzingAll(true);
    setErrorMessage(''); // Clear previous errors

    for (let i = 0; i < extractedImages.length; i++) {
      await handleAnalyzeSegment(extractedImages[i], i);
      // Introduce a delay to avoid API rate limits
      if (i < extractedImages.length - 1) { // Don't delay after the very last one
        await new Promise(resolve => setTimeout(resolve, 1500)); // 1.5 second delay
      }
    }
    setIsAnalyzingAll(false);
  };

  // Functions for continuous button adjustment
  const startAdjusting = useCallback((index, delta, isHorizontal) => {
    // Clear any existing interval to prevent multiple intervals running
    if (intervalRef.current) clearInterval(intervalRef.current);

    const adjust = () => {
      if (isHorizontal) {
        setHorizontalCutPoints(prev => {
          const newPoints = [...prev];
          const currentValue = newPoints[index];
          const newValue = Math.max(0, Math.min(originalImage.height, currentValue + delta));
          newPoints[index] = newValue;
          return newPoints.sort((a, b) => a - b);
        });
      } else {
        setVerticalCutPoints(prev => {
          const newPoints = [...prev];
          const currentValue = newPoints[index];
          const newValue = Math.max(0, Math.min(originalImage.width, currentValue + delta));
          newPoints[index] = newValue;
          return newPoints.sort((a, b) => a - b);
        });
      }
    };

    // Immediate adjustment on first click
    adjust();

    // Start interval for continuous adjustment after a short delay
    intervalRef.current = setInterval(adjust, 100); // Adjust every 100ms
  }, [originalImage, setHorizontalCutPoints, setVerticalCutPoints]);

  const stopAdjusting = useCallback(() => {
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);


  return (
    <div className="min-h-screen bg-gradient-to-br from-indigo-500 to-purple-600 flex flex-col items-center justify-center p-4 font-inter text-gray-800">
      <div className="bg-white p-8 rounded-xl shadow-2xl w-full max-w-4xl text-center">
        <h1 className="text-4xl font-extrabold mb-2 text-gray-900 drop-shadow-md">
          Image Splitter Tool
        </h1>
        <p className="text-sm text-gray-600 mb-6">
          made by <a href="https://github.com/vuvuvu/image-splitter-tool" target="_blank" rel="noopener noreferrer" className="text-purple-600 hover:text-purple-800 underline">vUvu</a>
        </p>

        {/* Info Buttons */}
        <div className="flex flex-wrap justify-center gap-4 mb-6">
          <button
            onClick={() => setShowWhyModal(true)}
            className="bg-gray-200 hover:bg-gray-300 text-gray-800 text-sm font-semibold py-2 px-4 rounded-full transition-colors duration-200"
          >
            Why I Made This
          </button>
          <button
            onClick={() => setShowHowToUseModal(true)}
            className="bg-gray-200 hover:bg-gray-300 text-gray-800 text-sm font-semibold py-2 px-4 rounded-full transition-colors duration-200"
          >
            How to Use
          </button>
          <button
            onClick={() => setShowPrivacyModal(true)}
            className="bg-gray-200 hover:bg-gray-300 text-gray-800 text-sm font-semibold py-2 px-4 rounded-full transition-colors duration-200"
          >
            Data Privacy & Usage
          </button>
        </div>

        {/* Info Modals */}
        <InfoModal
          title="Why I Made This"
          isOpen={showWhyModal}
          onClose={() => setShowWhyModal(false)}
        >
          <p>This application was created to easily split images, especially those generated by AI that don't always align perfectly to a grid. Image generation AIs can produce multiple variations or emotes within a single output image, but they often don't adhere to precise pixel grids.</p>
          <p>This tool allows users to define custom cut lines, extract individual segments, and even get AI-powered descriptions of their original image and its segments for better understanding and organization.</p>
          <p>The goal is to help quickly prepare your AI-generated content for use by making the splitting and metadata generation process easy and efficient.</p>
        </InfoModal>
        <InfoModal
          title="How to Use"
          isOpen={showHowToUseModal}
          onClose={() => setShowHowToUseModal(false)}
        >
          <p><span className="font-medium">1. Upload:</span> Select a PNG or JPG image.</p>
          <p><span className="font-medium">2. Add Cuts:</span> Use "Add Horizontal Cut" and "Add Vertical Cut" buttons to add lines.</p>
          <p><span className="font-medium">3. Adjust Cuts:</span> Type pixel values directly into the input boxes, or use the "&lt;" / "&gt;" buttons for precise adjustments.</p>
          <p><span className="font-medium">4. Extract:</span> Click "Extract Segments" to split the image.</p>
          <p><span className="font-medium">5. Analyze (Optional):</span> "Describe Original Image" gets overall description. "Analyze Segment" gets description for individual parts. "Analyze All Segments" processes all at once.</p>
          <p><span className="font-medium">6. Download:</span> Enter a "Prepended group name" (optional), then click "Download All Segments" to save PNGs and a text file of descriptions.</p>
        </InfoModal>
        <InfoModal
          title="Data Privacy & Usage"
          isOpen={showPrivacyModal}
          onClose={() => setShowPrivacyModal(false)}
        >
          <p><span className="font-medium">What is sent to Google:</span></p>
          <ul className="list-disc list-inside ml-4 space-y-1">
              <li>When you click "Describe Original Image," the data of your *entire* image (temporarily converted to a base64 string) is sent to Google's Gemini AI model to generate a text description.</li>
              <li>When you click "Analyze Segment ✨" or "Analyze All Segments ✨", the data for the *specific image segment(s)* being analyzed (temporarily converted to a base64 string) is sent to Google's Gemini AI model to generate titles and descriptions.</li>
              <li>These AI requests are processed by Google's secure infrastructure.</li>
          </ul>
          <p><span className="font-medium">What stays local in your browser:</span></p>
          <ul className="list-disc list-inside ml-4 space-y-1">
              <li>Your original uploaded image file itself is loaded and processed entirely within your web browser. It is <span className="font-medium underline">not</span> uploaded to my (the AI model's) servers or stored persistently by this application.</li>
              <li>The cut point coordinates you set and adjust.</li>
              <li>The extracted image segments are generated and held in your browser's memory until you download them.</li>
              <li>All your interactions with the application's interface.</li>
          </ul>
          <p><span className="font-medium">No Data Storage:</span> This tool is designed purely for client-side processing. Your images and generated descriptions are not stored persistently by this application after you close your browser tab or navigate away.</p>
        </InfoModal>

        {/* Input section for image upload and grid settings */}
        <div className="mb-8 p-6 bg-gray-50 rounded-lg shadow-inner border border-gray-200">
          <label htmlFor="image-upload" className="block text-lg font-semibold text-gray-700 mb-3 cursor-pointer">
            Upload Your Image
          </label>
          <input
            id="image-upload"
            type="file"
            accept="image/*"
            onChange={handleImageUpload}
            className="block w-full text-sm text-gray-500
                       file:mr-4 file:py-2 file:px-4
                       file:rounded-full file:border-0
                       file:text-sm file:font-semibold
                       file:bg-purple-50 file:text-purple-700
                       hover:file:bg-purple-100 mb-4 cursor-pointer"
          />

          {imageSrc && (
            <div className="flex flex-col md:flex-row items-start justify-center space-y-8 md:space-y-0 md:space-x-8 mt-6">
              <div className="flex-shrink-0 w-full md:w-1/2 flex flex-col items-center">
                <h2 className="text-xl font-semibold text-gray-800 mb-3">Original Image Preview</h2>
                <div className="border-2 border-dashed border-gray-300 rounded-lg overflow-hidden flex items-center justify-center bg-gray-100 max-w-full">
                  {/* Canvas to display the original image for user reference */}
                  <canvas ref={canvasRef} className="max-w-full h-auto rounded-lg shadow-md"></canvas>
                </div>
                {originalImage && (
                  <p className="mt-2 text-sm text-gray-600">
                    Image Resolution: {originalImage.width}x{originalImage.height} pixels
                  </p>
                )}
                {originalImage && (
                  <button
                    onClick={handleDescribeOriginalImage}
                    disabled={originalImageDescription === 'loading'}
                    className="mt-4 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow-md
                               transform transition duration-300 ease-in-out hover:scale-105 active:scale-95
                               disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2"
                  >
                    {originalImageDescription === 'loading' ? 'Describing... ✨' : 'Describe Original Image ✨'}
                  </button>
                )}
                {originalImageDescription && originalImageDescription !== 'loading' && originalImageDescription !== 'error' && (
                  <div className="mt-4 p-3 bg-blue-50 rounded-lg border border-blue-200 text-left text-sm text-blue-800">
                    <p className="font-semibold mb-1">Description:</p>
                    <p>{originalImageDescription}</p>
                  </div>
                )}
                 {originalImageDescription === 'error' && (
                  <div className="mt-4 p-3 bg-red-100 rounded-lg border border-red-400 text-left text-sm text-red-700">
                    <p>Error generating description. Please try again.</p>
                  </div>
                )}
              </div>

              {/* Cut point controls */}
              <div className="flex flex-col space-y-6 w-full md:w-1/2">
                {/* Horizontal Cut Points */}
                <div className="bg-white p-4 rounded-lg shadow-sm border border-gray-200">
                  <h3 className="text-lg font-semibold text-gray-800 mb-3">Horizontal Cuts (Y-coordinates from bottom)</h3>
                  <button
                    onClick={addHorizontalCutPoint}
                    disabled={!originalImage || horizontalDivisionIteration >= 16}
                    className="mb-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg
                               transform transition duration-300 ease-in-out hover:scale-105 active:scale-95
                               disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    Add Horizontal Cut
                  </button>
                  <div className="space-y-3">
                    {/* Display horizontal cut points sorted from top to bottom (visually), but use original index for update/remove */}
                    {[...horizontalCutPoints].sort((a, b) => b - a).map((point, sortedIndex) => {
                      const originalIndex = horizontalCutPoints.indexOf(point);
                      return (
                      <div key={originalIndex} className="flex items-center space-x-2">
                        <label htmlFor={`h-cut-${originalIndex}`} className="text-gray-700 whitespace-nowrap">Y-Cut {
                            sortedIndex + 1 // Display index based on sorted order
                        }:</label>
                        <button
                          onMouseDown={() => startAdjusting(originalIndex, -1, true)}
                          onMouseUp={stopAdjusting}
                          onMouseLeave={stopAdjusting}
                          onTouchStart={(e) => { e.preventDefault(); startAdjusting(originalIndex, -1, true); }}
                          onTouchEnd={stopAdjusting}
                          className="bg-gray-300 hover:bg-gray-400 text-gray-800 py-2 px-3 rounded-md transition duration-300 ease-in-out"
                          title="Decrease Y-coordinate"
                        >
                          &lt;
                        </button>
                        <input
                          id={`h-cut-${originalIndex}`}
                          type="number"
                          min="0"
                          max={originalImage ? originalImage.height : 9999}
                          value={point}
                          onChange={(e) => updateHorizontalCutPoint(originalIndex, e.target.value)}
                          className="flex-grow p-2 border border-gray-300 rounded-md focus:ring-purple-500 focus:border-purple-500 text-center"
                        />
                        <button
                          onMouseDown={() => startAdjusting(originalIndex, 1, true)}
                          onMouseUp={stopAdjusting}
                          onMouseLeave={stopAdjusting}
                          onTouchStart={(e) => { e.preventDefault(); startAdjusting(originalIndex, 1, true); }}
                          onTouchEnd={stopAdjusting}
                          className="bg-gray-300 hover:bg-gray-400 text-gray-800 py-2 px-3 rounded-md transition duration-300 ease-in-out"
                          title="Increase Y-coordinate"
                        >
                          &gt;
                        </button>
                        <button
                          onClick={() => removeHorizontalCutPoint(originalIndex)}
                          className="bg-red-500 hover:bg-red-600 text-white p-2 rounded-md transition duration-300 ease-in-out hover:scale-110"
                          title="Remove Cut Point"
                        >
                          &times;
                        </button>
                      </div>
                      );
                    })}
                  </div>
                </div>

                {/* Vertical Cut Points */}
                <div className="bg-white p-4 rounded-lg shadow-sm border border-gray-200">
                  <h3 className="text-lg font-semibold text-gray-800 mb-3">Vertical Cuts (X-coordinates from left)</h3>
                  <button
                    onClick={addVerticalCutPoint}
                    disabled={!originalImage || verticalDivisionIteration >= 16}
                    className="mb-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg
                               transform transition duration-300 ease-in-out hover:scale-105 active:scale-95
                               disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    Add Vertical Cut
                  </button>
                  <div className="space-y-3">
                    {verticalCutPoints.map((point, index) => (
                      <div key={index} className="flex items-center space-x-2">
                        <label htmlFor={`v-cut-${index}`} className="text-gray-700 whitespace-nowrap">X-Cut {index + 1}:</label>
                        <button
                          onMouseDown={() => startAdjusting(index, -1, false)}
                          onMouseUp={stopAdjusting}
                          onMouseLeave={stopAdjusting}
                          onTouchStart={(e) => { e.preventDefault(); startAdjusting(index, -1, false); }}
                          onTouchEnd={stopAdjusting}
                          className="bg-gray-300 hover:bg-gray-400 text-gray-800 py-2 px-3 rounded-md transition duration-300 ease-in-out"
                          title="Decrease X-coordinate"
                        >
                          &lt;
                        </button>
                        <input
                          id={`v-cut-${index}`}
                          type="number"
                          min="0"
                          max={originalImage ? originalImage.width : 9999}
                          value={point}
                          onChange={(e) => updateVerticalCutPoint(index, e.target.value)}
                          className="flex-grow p-2 border border-gray-300 rounded-md focus:ring-purple-500 focus:border-purple-500 text-center"
                        />
                        <button
                          onMouseDown={() => startAdjusting(index, 1, false)}
                          onMouseUp={stopAdjusting}
                          onMouseLeave={stopAdjusting}
                          onTouchStart={(e) => { e.preventDefault(); startAdjusting(index, 1, false); }}
                          onTouchEnd={stopAdjusting}
                          className="bg-gray-300 hover:bg-gray-400 text-gray-800 py-2 px-3 rounded-md transition duration-300 ease-in-out"
                          title="Increase X-coordinate"
                        >
                          &gt;
                        </button>
                        <button
                          onClick={() => removeVerticalCutPoint(index)}
                          className="bg-red-500 hover:bg-red-600 text-white p-2 rounded-md transition duration-300 ease-in-out hover:scale-110"
                          title="Remove Cut Point"
                        >
                          &times;
                        </button>
                      </div>
                    ))}
                  </div>
                </div>

                <button
                  onClick={handleExtractImages}
                  disabled={isLoading || !originalImage}
                  className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                             transform transition duration-300 ease-in-out hover:scale-105 active:scale-95
                             disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 mt-4"
                >
                  {isLoading ? 'Extracting...' : 'Extract Segments'}
                </button>
              </div>
            </div>
          )}
        </div>

        {/* Error message display */}
        {errorMessage && (
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-4" role="alert">
            <strong className="font-bold">Error: </strong>
            <span className="block sm:inline">{errorMessage}</span>
          </div>
        )}

        {/* Display extracted images */}
        {extractedImages.length > 0 && (
          <div className="mt-8">
            <h2 className="text-3xl font-bold mb-6 text-gray-900 drop-shadow-sm">Extracted Segments</h2>

            {/* Analyze All Segments Button */}
            <button
              onClick={handleAnalyzeAllSegments}
              disabled={isAnalyzingAll || extractedImages.length === 0}
              className="mb-4 bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                         transform transition duration-300 ease-in-out hover:scale-105 active:scale-95
                         disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2"
            >
              {isAnalyzingAll ? 'Analyzing All... ✨' : 'Analyze All Segments ✨'}
            </button>

            {/* Group Name Input (Foldable) */}
            <div className="mb-4 flex flex-col items-center justify-center">
              <label htmlFor="group-name" className="text-gray-700 font-semibold mb-2 flex items-center cursor-pointer" onClick={() => setShowGroupInfoModal(true)}>
                Prepended group name (Click for info)
                <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 ml-2 text-gray-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 1.5 01-9 9 9 9 01-9-9 9 9 019-9 9 9 019 9z" />
                </svg>
              </label>
              <input
                id="group-name"
                type="text"
                placeholder="e.g., MyEmotes"
                value={groupName}
                onChange={(e) => setGroupName(e.target.value)}
                className="p-2 border border-gray-300 rounded-md focus:ring-purple-500 focus:border-purple-500 text-center w-64"
              />
            </div>
            <InfoModal
              title="Prepended Group Name"
              isOpen={showGroupInfoModal}
              onClose={() => setShowGroupInfoModal(false)}
            >
              <p>This optional field allows you to add a prefix to the filenames of your downloaded image segments and the text file containing their descriptions.</p>
              <p>For example, if you enter "SummerCollection" and download a segment, its filename might be `SummerCollection_segment_1.png`. The description file would be named `SummerCollection_image_descriptions.txt`.</p>
              <p>This helps in organizing your extracted images, especially if you process multiple batches.</p>
            </InfoModal>

            <button
              onClick={handleBatchDownload}
              disabled={isDownloading}
              className="mb-6 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg
                         transform transition duration-300 ease-in-out hover:scale-105 active:scale-95
                         disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
            >
              {isDownloading ? 'Downloading All...' : 'Download All Segments (PNG + Descriptions)'}
            </button>
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 justify-items-center">
              {extractedImages.map((imgDataUrl, index) => (
                <div key={index} className="bg-white p-4 rounded-lg shadow-md border border-gray-200 flex flex-col items-center">
                  <img
                    src={imgDataUrl}
                    alt={`Extracted Image ${index + 1}`}
                    className="w-full h-32 object-contain mb-4 rounded-md border border-gray-100 bg-gray-50"
                  />
                  <a
                    href={imgDataUrl}
                    download={`${groupName ? `${groupName}_` : ''}segment_${index + 1}.png`}
                    className="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-full
                               transform transition duration-300 ease-in-out hover:scale-105 active:scale-95 text-sm"
                  >
                    Download Segment {index + 1}
                  </a>
                  <button
                    onClick={() => handleAnalyzeSegment(imgDataUrl, index)}
                    disabled={segmentDescriptions[index]?.status === 'loading'}
                    className="mt-3 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow-md
                               transform transition duration-300 ease-in-out hover:scale-105 active:scale-95 text-sm
                               disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    {segmentDescriptions[index]?.status === 'loading' ? 'Analyzing... ✨' : 'Analyze Segment ✨'}
                  </button>
                  {segmentDescriptions[index]?.status === 'success' && (
                    <div className="mt-2 p-2 bg-blue-50 rounded-lg border border-blue-200 text-left text-xs text-blue-800 w-full">
                      <p className="font-semibold mb-1">Title: {segmentDescriptions[index].title}</p>
                      <p className="font-semibold mb-1">Description:</p>
                      <p>{segmentDescriptions[index].description}</p>
                    </div>
                  )}
                  {segmentDescriptions[index]?.status === 'error' && (
                    <div className="mt-2 p-2 bg-red-100 rounded-lg border border-red-400 text-left text-xs text-red-700 w-full">
                      <p>Error analyzing segment.</p>
                    </div>
                  )}
                </div>
              ))}
            </div>
          </div>
        )}
      </div>

      {/* Footer */}
      <footer className="mt-8 p-4 text-center text-gray-200 text-sm">
        Created by <a href="https://github.com/vuvuvu/image-splitter-tool" target="_blank" rel="noopener noreferrer" className="text-purple-200 hover:text-purple-100 underline font-medium">vUvu</a>
      </footer>

      {/* External JS Libraries for Zipping and File Saving */}
      <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
      {/* Tailwind CSS Script - must be at the end of the body or head */}
      <script src="https://cdn.tailwindcss.com"></script>
      {/* Configure Tailwind to use Inter font and modal animation */}
      <style>
        {`
          @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');
          body {
            font-family: 'Inter', sans-serif;
          }
          @keyframes scaleIn {
            from {
              transform: scale(0.95);
              opacity: 0;
            }
            to {
              transform: scale(1);
              opacity: 1;
            }
          }
          .animate-scaleIn {
            animation: scaleIn 0.2s ease-out forwards;
          }
        `}
      </style>
    </div>
  );
};

export default App;